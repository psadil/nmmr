---
title: "orthogonal"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{orthogonal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE
)
```


```{r setup, message=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(forcats)
library(nmmr)

size_shape <- 2
set.seed(1234)
```

# Introduction

NMM involves two techniques for looking at neuromodulation. One of them is based on model comparison, quantitatively looking at the difference between models. The other is based on a visualization, attempting to look directly at neuromodulation in the data. That visualization is the focus of this vignette.

# Data

After loading the library, you will have access to a dataset, `sub02`. 

```{r, data}
sub02[1:10,]
```

## The Challenge

Ideally, we could look at neuromodulation by plotting the voxel tuning function, for each voxel separately. That is an easy enough plot to generate, but it is insufficient. Here are the tuning functions for 12 voxels.

```{r, vtfs, fig.cap="Individual voxel tuning functions are too noisy to provide information about neuromodulation individually."}
sub02 %>%
  group_by(contrast, orientation) %>%
  slice_head(n=6) %>%
  whoppeR::WISEsummary(
    dependentvars = "y",
    withinvars = c("orientation", "contrast"),
    idvar = "voxel",
    betweenvars = "voxel") %>%
  ggplot(aes(x=orientation, y=y_mean, color = contrast)) +
  facet_wrap(~voxel) +
  geom_line() +
  geom_errorbar(aes(ymin=y_mean-y_sem, ymax=y_mean+y_sem)) +
  scale_color_viridis_d(option="inferno", end=.8)
```

The relevant effects are hard to parse in individual voxels. There are two issues. First, individual voxels are only weakly tuned. When tuning is flat, an additive shift and multiplicative gain look the same. Second, for many voxels, the effect of contrast is small. A weak effect of contrast further squashes the minor nuances. These issues will be handled in two steps.

# Low- vs. High-Contrast

First, we need some way to focus on the neuromodulation itself, rather than the tuning. The central idea, detailed in the main paper, is that we can assess multiplicative vs. additive shift by looking at the slope of a line made from the low-contrast tuning plotted against the high-contrast tuning.

```{r, add_mult, echo=FALSE, fig.cap="Reproduced from the paper."}

make_d <- function(raw,
                   kv = 2,
                   center = -pi/16,
                   m = 1.4,
                   a = 0.1,
                   p = 0.6) {
  d <- tibble(raw = raw) %>%
    crossing(
      Contrast = factor(c("Low", "High"), levels = c("Low", "High")),
      VTF = factor(
        c("Additive", "Multiplicative"),
        levels = c("Additive", "Multiplicative"))) %>%
    mutate(
      y = case_when(
        fct_match(Contrast, "Low") ~ CircStats::dmixedvm(raw, center, center+pi, kv, kv, p),
        fct_match(VTF, "Additive") ~ a + CircStats::dmixedvm(raw, center, center+pi, kv, kv, p),
        fct_match(VTF, "Multiplicative") ~ m*CircStats::dmixedvm(raw, center, center+pi, kv, kv, p)),
      orientation = CircStats::deg(raw / 2))
  return(d)
}

test_oris <- make_d(seq(-pi, pi-2*pi/8, length.out = 8)) %>%
  group_by(orientation, VTF) %>%
  mutate(
    high = max(y),
    higher = high + 0.025,
    highest = 0.6) %>%
  filter(fct_match(Contrast, "Low"))

a <- make_d(seq(-pi, pi, length.out = 1000)) %>%
  ggplot(aes(x=orientation)) +
  facet_wrap(~VTF, nrow=2, strip.position = "left") +
  geom_segment(
    aes(
      xend = orientation,
      y = y,
      yend = high),
    data = test_oris,
    show.legend = FALSE,
    size = .4) +
  geom_point(
    aes(
      x = orientation,
      y = highest,
      shape = factor(orientation)),
    data = test_oris %>%filter(fct_match(VTF, "Multiplicative")),
    show.legend = FALSE,
    size = size_shape) +
  geom_segment(
    aes(
      xend = orientation,
      y = 0),
    yend = 0.6,
    alpha = 0.25,
    data = test_oris,
    size = 0.25) +
  geom_line(
    aes(
      y = y,
      linetype = Contrast)) +
  scale_x_continuous(
    name = "Orientation",
    breaks = seq(-90, 90, length.out = 3),
    labels = seq(-90, 90, length.out = 3)) +
  scale_y_continuous(
    name = expression(beta),
    labels = NULL,
    breaks = NULL) +
  coord_cartesian(ylim = c(0, 0.6)) +
  scale_color_viridis_c(option = "inferno", end = .8) +
  scale_linetype_manual(values = c("solid", "dashed")) +
  scale_shape_manual(values = c(1:8)) +
  theme_classic(
    base_size = 10,
    base_family = "ArialMT") +
  theme(
    axis.line.y = element_blank(),
    rect = element_blank(),
    legend.position = "bottom")

b <- make_d(seq(-pi, pi-2*pi/8, length.out = 8)) %>%
  group_by(VTF, orientation) %>%
  mutate(avg = mean(y)) %>%
  group_by(VTF, Contrast) %>%
  mutate(rank = rank(y)) %>%
  ungroup() %>%
  pivot_wider(names_from = Contrast, values_from = y) %>%
  ggplot(aes(x = Low, y = High)) +
  facet_wrap(~VTF, nrow = 2) +
  geom_abline(
    slope = 1,
    intercept = 0) +
  geom_line(alpha = 0.25) +
  geom_point(
    aes(shape = factor(orientation)),
    show.legend = FALSE,
    size = size_shape) +
  scale_x_continuous(
    name = expression(paste("Low Contrast ", beta)),
    labels = NULL,
    breaks = NULL) +
  scale_y_continuous(
    name = expression(paste("High Contrast ", beta)),
    labels = NULL,
    breaks = NULL) +
  coord_cartesian(xlim = c(0,0.5), ylim = c(0,0.5)) +
  scale_color_viridis_c(option = "inferno", end = .8) +
  scale_linetype_manual(values = c("dotted", "dashed")) +
  scale_shape_manual(values = 1:8) +
  theme_classic(
    base_size = 10,
    base_family = "ArialMT") +
  theme(
    rect = element_blank(),
    legend.position = "none",
    strip.text = element_blank()) +
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size = 0.5)

leg <- cowplot::get_legend(a + theme(legend.justification = "left"))

cowplot::plot_grid(
  a + theme(legend.position = "none"),
  b,
  nrow = 1,
  axis = "tblr",
  align = "hv") %>%
  cowplot::plot_grid(
    leg,
    nrow=2,
    rel_heights = c(1,0.01)) +
  theme(plot.margin = unit(c(0,0,12,0), units ="points"))


```

Unlike the main Bayesian approach, this approach does not assume a particular for either the neural tuning function or weight distribution. 


# Total Least Squares


## Sample Data

Here is a toy example to to build intuition for the function. The observed variables `x` and `y` 

$$
\begin{align}
z & \sim N(0, 1) \\
x & \sim N(z, 1) \\
y & \sim N(2z, 1)
\end{align}
$$

Next, simulate 1000 draws from this model.

```{r, tls_data}
N <- 1000
d <- tibble(z = rnorm(N)) %>%
  mutate(
    x = rnorm(N, z),
    y = rnorm(N, 2*z))

```


## Ordinary Least Squares will not work

Unfortunately, we cannot recover the desired slope through typical regression. 

```{r, tls_plot, fig.cap="We want to estimate the dashed line, which has a slope of 2 (dashed line). However, Ordinary Least Squares (OLS) provides an estimate that is biased towards 0 (solid line)."}

ls <- lm(y ~ x, data=d)

d %>%
  ggplot(aes(x=x, y=y)) +
  geom_point(alpha = .2) +
  geom_abline(intercept=coef(ls)[1], slope=coef(ls)[2], color="blue") +
  coord_fixed() +
  ggtitle(glue::glue("OLS slope: {round(coef(ls)[2], digits=2)}")) +
  geom_abline(intercept=0, slope=2, linetype = "dashed", color="blue")
```


## Instead, use total least squares


The main function for this is called `get_slope`. 

```{r, tls_slope}
slope <- get_slope(d$x, d$y)
```


```{r, tls_show}

fits <- crossing(i = 1:1000,
         n = 1:N) %>%
  mutate(
    z = rnorm(n()),
    x = rnorm(n(), z),
    y = rnorm(n(), 2*z)) %>%
  group_nest(i) %>%
  mutate(
    OLS = purrr::map_dbl(data, ~lm(y ~ x, data=.) %>% coef() %>% magrittr::extract(2)),
    TLS = purrr::map_dbl(data, ~get_slope(.$x, .$y))) %>%
  select(-data) %>%
  pivot_longer(c(OLS, TLS), names_to = "Method", values_to = "Estimate")

```


```{r, ls_compare, fig.cap="Across "}
fits %>%
  ggplot(aes(x=Estimate)) +
  geom_histogram(aes(fill=Method), bins = 100) +
  geom_vline(xintercept = 2, linetype = "dashed")
```


# Application to Data

When your data are formatted according to the 

```{r, pivot}

sub02_wide <- sub02 %>%
  pivot_wider(names_from = contrast, values_from = y)

sub02_wide[1:10,]
```


```{r, group}

slopes <- sub02_wide %>%
  get_slope_by_group(voxel, low, high)

```


```{r, voxel_slopes, fig.cap="When looking at all of the voxels, some of the slopes are spuriously high."}

slopes %>%
  ggplot(aes(x=slope)) +
  geom_histogram(bins = 200) +
  geom_vline(xintercept = 1)

```


## Thresholding

An issue with the above is that many voxels are only weakly affected by contrast, meaning

```{r, circle, fig.cap="When voxels are poorly tuned, the best-fitting line can easily be one that is nearly vertical."}

sub02_wide %>%
  filter(forcats::fct_match(voxel, "209671")) %>%
  ggplot(aes(x=low, y = high)) +
  geom_point() +
  coord_fixed() 

```


```{r}
ranks <- cross_threshold(sub02_wide, voxel, low, high, participant = sub)
```


```{r}
left_join(ranks, slopes, by = c("voxel")) %>%
  ggplot(aes(x=slope)) +
  facet_wrap(~Threshold, scales = "free", labeller = label_both) +
  geom_histogram(bins = 20) +
  geom_vline(xintercept = 1)
```

