---
title: "orthogonal"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{orthogonal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE
)
```


```{r setup, message=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(forcats)
library(purrr)
library(nmmr)

size_shape <- 2
set.seed(1234)
```

# Introduction

NMM involves two techniques for looking at neuromodulation. One of them is based on model comparison, quantitatively looking at the difference between models. The other is based on a visualization, attempting to look directly at neuromodulation in the data. That visualization is the focus of this vignette.

# The Challenge

Ideally, we could look at neuromodulation by plotting the voxel tuning function, for each voxel separately. That is an easy enough plot to generate, but it is insufficient. Here are the tuning functions for 12 voxels.

```{r, vtfs, fig.cap="Individual voxel tuning functions are too noisy to provide information about neuromodulation individually."}
sub02 %>%
  group_by(contrast, orientation, run, ses) %>%
  slice_head(n=6) %>%
  group_by(voxel) %>%
  group_nest() %>%
  mutate(
    data = map(
      data, 
      ~WISEsummary(.x, dependentvars = y, withinvars = c(orientation, contrast)))) %>%
  unnest(data) %>%
  ggplot(aes(x=orientation, y=y_mean, color = contrast)) +
  facet_wrap(~voxel, labeller = label_both) +
  geom_line() +
  geom_errorbar(aes(ymin=y_mean-y_sem, ymax=y_mean+y_sem)) +
  scale_color_viridis_d(option="inferno", end=.8)
```

The relevant effects are hard to parse in individual voxels. There are two issues. First, individual voxels are only weakly tuned. When tuning is flat, an additive shift and multiplicative gain look the same. Second, for many voxels, the effect of contrast is small. A weak effect of contrast further squashes the minor nuances. These issues will be handled in two steps: a conceptual leap and orthogonal regression.

# A plot

First, we need some way to focus on the neuromodulation itself, rather than the tuning. The central idea, detailed in the main paper, is that we can assess multiplicative vs. additive shift by looking at the slope of a line made from the low-contrast tuning plotted against the high-contrast tuning.


A key difference between the models we compared is that the multiplicative model allows the effect of contrast to vary by orientation whereas the additive model does not. Additive neuromodulation corresponds to an increase in neural activity at all orientations. Thus, regardless of the forms of the weight distribution and neural tuning function, additive neuromodulation causes the low-contrast tuning function to shift upwards uniformly across orientations. Hence, a scatterplot of the voxel’s response to high-contrast stimuli against its response to low-contrast stimuli has a slope of 1. In contrast, multiplicative neuromodulation corresponds to an increase in neural activity at the most preferred orientations, and a scatterplot of a voxel’s response to high versus low-contrast stimuli has a slope larger than 1. Therefore, the models can be differentiated by plotting high-contrast activity against low-contrast activity and calculating the slope of the best fitting line. A slope of one implies additive shift, but a slope greater than one implies multiplicative gain.

```{r, add_mult, echo=FALSE, fig.cap="Reproduced from the paper."}
library(patchwork)
make_d <- function(raw,
                   kv = 2,
                   center = -pi/16,
                   m = 1.4,
                   a = 0.1,
                   p = 0.6) {
  d <- tibble(raw = raw) %>%
    crossing(
      Contrast = factor(c("Low", "High"), levels = c("Low", "High")),
      VTF = factor(
        c("Additive", "Multiplicative"),
        levels = c("Additive", "Multiplicative"))) %>%
    mutate(
      y = case_when(
        fct_match(Contrast, "Low") ~ CircStats::dmixedvm(raw, center, center+pi, kv, kv, p),
        fct_match(VTF, "Additive") ~ a + CircStats::dmixedvm(raw, center, center+pi, kv, kv, p),
        fct_match(VTF, "Multiplicative") ~ m*CircStats::dmixedvm(raw, center, center+pi, kv, kv, p)),
      orientation = CircStats::deg(raw / 2))
  return(d)
}

test_oris <- make_d(seq(-pi, pi-2*pi/8, length.out = 8)) %>%
  group_by(orientation, VTF) %>%
  mutate(
    high = max(y),
    higher = high + 0.025,
    highest = 0.6) %>%
  filter(fct_match(Contrast, "Low"))

a <- make_d(seq(-pi, pi, length.out = 1000)) %>%
  ggplot(aes(x=orientation)) +
  facet_wrap(~VTF, nrow=2, strip.position = "left") +
  geom_segment(
    aes(
      xend = orientation,
      y = y,
      yend = high),
    data = test_oris,
    show.legend = FALSE,
    size = .4) +
  geom_point(
    aes(
      x = orientation,
      y = highest,
      shape = factor(orientation)),
    data = test_oris %>%filter(fct_match(VTF, "Multiplicative")),
    show.legend = FALSE,
    size = size_shape) +
  geom_segment(
    aes(
      xend = orientation,
      y = 0),
    yend = 0.6,
    alpha = 0.25,
    data = test_oris,
    size = 0.25) +
  geom_line(
    aes(
      y = y,
      linetype = Contrast)) +
  scale_x_continuous(
    name = "Orientation",
    breaks = seq(-90, 90, length.out = 3),
    labels = seq(-90, 90, length.out = 3)) +
  scale_y_continuous(
    name = expression(beta),
    labels = NULL,
    breaks = NULL) +
  coord_cartesian(ylim = c(0, 0.6)) +
  scale_color_viridis_c(option = "inferno", end = .8) +
  scale_linetype_manual(values = c("solid", "dashed")) +
  scale_shape_manual(values = c(1:8)) +
  theme_classic(base_size = 10) +
  theme(
    axis.line.y = element_blank(),
    rect = element_blank(),
    legend.position = "bottom")

b <- make_d(seq(-pi, pi-2*pi/8, length.out = 8)) %>%
  group_by(VTF, orientation) %>%
  mutate(avg = mean(y)) %>%
  group_by(VTF, Contrast) %>%
  mutate(rank = rank(y)) %>%
  ungroup() %>%
  pivot_wider(names_from = Contrast, values_from = y) %>%
  ggplot(aes(x = Low, y = High)) +
  facet_wrap(~VTF, nrow = 2) +
  geom_abline(
    slope = 1,
    intercept = 0) +
  geom_line(alpha = 0.25) +
  geom_point(
    aes(shape = factor(orientation)),
    show.legend = FALSE,
    size = size_shape) +
  scale_x_continuous(
    name = expression(paste("Low Contrast ", beta)),
    labels = NULL,
    breaks = NULL) +
  scale_y_continuous(
    name = expression(paste("High Contrast ", beta)),
    labels = NULL,
    breaks = NULL) +
  coord_cartesian(xlim = c(0,0.5), ylim = c(0,0.5)) +
  scale_color_viridis_c(option = "inferno", end = .8) +
  scale_linetype_manual(values = c("dotted", "dashed")) +
  scale_shape_manual(values = 1:8) +
  theme_classic(base_size = 10) +
  theme(
    rect = element_blank(),
    legend.position = "none",
    strip.text = element_blank()) +
  annotate("segment", x=-Inf, xend=Inf, y=-Inf, yend=-Inf, size = 0.5)


a + b + plot_layout(nrow=1)


```


# Total Least Squares

[Deming Regression](https://en.wikipedia.org/wiki/Deming_regression), (specifically orthogonal regression), [measurement error models](https://en.wikipedia.org/wiki/Errors-in-variables_models).



## Sample Data

Here is a toy example to to build intuition for the function. The observed variables `x` and `y` 

$$
\begin{align}
z & \sim N(0, 1) \\
x & \sim N(z, 1) \\
y & \sim N(2z, 1)
\end{align}
$$

Next, simulate 1000 draws from this model.

```{r, tls_data}
N <- 1000
d <- tibble(z = rnorm(N)) %>%
  mutate(
    x = rnorm(N, z),
    y = rnorm(N, 2*z))

```


## Ordinary Least Squares will not work

Unfortunately, we cannot recover the desired slope through typical regression. 

```{r, tls_plot, fig.cap="We want to estimate the dashed line, which has a slope of 2 (dashed line). However, Ordinary Least Squares (OLS) provides an estimate that is biased towards 0 (solid line)."}

ls <- lm(y ~ x, data=d)

d %>%
  ggplot(aes(x=x, y=y)) +
  geom_point(alpha = .2) +
  geom_abline(intercept=coef(ls)[1], slope=coef(ls)[2], color="blue") +
  coord_fixed() +
  ggtitle(glue::glue("OLS slope: {round(coef(ls)[2], digits=2)}")) +
  geom_abline(intercept=0, slope=2, linetype = "dashed", color="blue")
```

This issue is known as [Regression Dilution](https://en.wikipedia.org/wiki/Regression_dilution). 

## Instead, use total least squares

The main function for this is called `get_slope`. 

```{r, tls_slope}
slope <- get_slope(d$x, d$y)
```


```{r, tls_show}

fits <- crossing(
  i = 1:1000,
  n = 1:N) %>%
  mutate(
    z = rnorm(n()),
    x = rnorm(n(), z),
    y = rnorm(n(), 2*z)) %>%
  group_nest(i) %>%
  mutate(
    OLS = purrr::map_dbl(data, ~lm(y ~ x, data=.) %>% coef() %>% magrittr::extract(2)),
    TLS = purrr::map_dbl(data, ~get_slope(.$x, .$y))) %>%
  select(-data) %>%
  pivot_longer(c(OLS, TLS), names_to = "Method", values_to = "Estimate")

```


```{r, ls_compare, fig.cap="Across many simulated datasets, the Ordinary Least Squares (OLS) method estimates a slope that is too small, whereas the orthogonal regression (TLS) is unbiased."}
fits %>%
  ggplot(aes(x=Estimate)) +
  geom_histogram(aes(fill=Method), bins = 100) +
  geom_vline(xintercept = 2, linetype = "dashed")
```

# Application to Data

This 

```{r raw_data}
sub02[1:10,]
```

For more details, see the help page of the dataset: `?sub02`.


When your data are formatted according to the 

```{r, pivot}

sub02_wide <- sub02 %>%
  pivot_wider(names_from = contrast, values_from = y)

sub02_wide[1:10,]
```


```{r, group}

slopes <- sub02_wide %>%
  get_slope_by_group(voxel, low, high)

```


```{r, voxel_slopes, fig.cap="When looking at all of the voxels, some of the slopes are spuriously high."}

slopes %>%
  ggplot(aes(x=slope)) +
  geom_histogram(bins = 200) +
  geom_vline(xintercept = 1)

```


## Thresholding

An issue with the above is that many voxels are only weakly affected by contrast, meaning

```{r, circle, fig.cap="When voxels are poorly tuned, the best-fitting line can easily be one that is nearly vertical."}

sub02_wide %>%
  filter(forcats::fct_match(voxel, "209671")) %>%
  ggplot(aes(x=low, y = high)) +
  geom_point() +
  coord_fixed() 

```


```{r}
ranks <- cross_threshold(sub02_wide, voxel, low, high, participant = sub)
```


```{r}
left_join(ranks, slopes, by = c("voxel")) %>%
  ggplot(aes(x=slope)) +
  facet_wrap(~Threshold, scales = "free", labeller = label_both) +
  geom_histogram(bins = 20) +
  geom_vline(xintercept = 1)
```

